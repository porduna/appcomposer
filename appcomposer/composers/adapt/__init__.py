import threading
from functools import wraps

from flask import Blueprint, json

import appcomposer.appstorage.api as appstorage
from appcomposer.application import app

# Required imports for a customized app view for the adapt tool (a possible block to be refactored?)
from appcomposer.babel import lazy_gettext
from appcomposer.login import requires_login

info = {
    'blueprint': 'adapt',
    'url': '/composers/adapt',

    'new_endpoint': 'adapt.adapt_appsearch',
    'edit_endpoint': 'adapt.adapt_edit',
    'create_endpoint': 'adapt.adapt_create',
    'duplicate_endpoint': 'adapt.adapt_duplicate',
    'delete_endpoint': 'dummy.delete',

    'name': lazy_gettext('Adaptor Composer'),
    'description': lazy_gettext('Adapt an existing app.')
}

adapt_blueprint = Blueprint(info['blueprint'], __name__)
adaptors_blueprints = []

ADAPTORS = {
    # 'identifier' : {
    #     'initial' : function,
    #     'adaptor' : adaptor_object,
    #     'name' : 'Something',
    #     'description' : 'Description', # Optional
    #     'about_endpoint' : 'Flask endpoint', # Optional
    # }
}

import view_type_selection
import view_create_app
import view_duplicate
import view_edit
import view_appsearch
import view_preview


#
# Register the plug-ins. In the future we might have something more serious, relying on the
# extension system for flask.
#

_current_plugin = threading.local()


def load_plugins():
    # These plug-ins have been deprecated in favor of jsconfig
    # plugins = ['concept_mapper', 'hypothesis', 'edt', 'jsconfig']
    plugins = ['jsconfig']

    for plugin in app.config.get('ADAPT_PLUGINS', []):
        if plugin not in plugins:
            plugins.append(plugin)

    for plugin in plugins:
        _current_plugin.name = plugin
        try:
            __import__('appcomposer.composers.adapt.ext.%s' % plugin)
        finally:
            _current_plugin.name = None


class AdaptorPlugin(object):
    """ An AdaptorPlugin is an object generated by the adaptor and consumed 
    each plug-in. It contains the Flask blueprint as well as some useful 
    information (name, initial structure, etc.)."""

    def __init__(self, name, blueprint, initial=None, description=None, about_endpoint=None):
        self.name = name
        self.blueprint = blueprint
        if initial is None:
            self.initial = {}
        else:
            self.initial = initial
        self.description = description
        self._edit_endpoint = None
        self._data = None
        self.about_endpoint = about_endpoint

    def route(self, *args, **kwargs):
        return self.blueprint.route(*args, **kwargs)

    def get_name(self, appid):
        app = appstorage.get_app(appid)
        return app.name

    def load_data(self, appid):
        """ Wrapper of the appstorage API. It returns a valid JSON file. """
        app = appstorage.get_app(appid)
        return json.loads(app.data)

    def save_data(self, app_id, data):
        """ Wrapper of the appstorage API. It saves the data in JSON format. """
        app = appstorage.get_app(app_id)
        appstorage.update_app_data(app, data)

    def edit_route(self, func):
        """ Generates a route that already controls that the App ID exists

        @adaptor.edit_route
        def edit(app_id):
            # Whatever flask code
            # You may refer to this method as url_for('.edit')
            return "something"
        """
        self._edit_endpoint = '%s.%s' % (self.name, func.__name__)

        @self.blueprint.route("/edit/<appid>/", methods=['GET', 'POST'])
        @requires_login
        @wraps(func)
        def wrapper(appid):
            # TODO: Improve this: do not load the whole thing. We just need the ID and so on.
            if not appid:
                return "appid not provided", 400
            app = appstorage.get_app(appid)
            if app is None:
                return "App not found", 500

            data = json.loads(app.data)
            adaptor_type = data["adaptor_type"]

            if adaptor_type != self.name:
                return "This Adaptor is not of this adaptor type", 400

            return func(appid)

        return wrapper


def create_adaptor(full_name, initial={}, description=None, about_endpoint=None):
    # Make sure that:
    # 1. It's serializable to JSON (as it's gonna be later in the appstorage layer)
    # 2. It's never modified by any function
    initial = json.loads(json.dumps(initial))

    plugin = getattr(_current_plugin, 'name', None)
    if not plugin:
        raise Exception(
            "The plug-in should not be loaded directly. It should be loaded by the load_plugins() method in the beginning")

    for blueprint in adaptors_blueprints:
        if blueprint.name == plugin:
            raise Exception(
                "The plug-in %s is already registered. Don't call the method twice and check that the plug-in name is not in collision with other plug-in.")

    import_name = 'golab_adapt_%s' % plugin
    url_prefix = '/composers/adapt/adaptors/%s' % plugin

    plugin_blueprint = Blueprint(plugin, import_name, url_prefix=url_prefix, template_folder='templates',
                                 static_folder='static')

    adaptors_blueprints.append(plugin_blueprint)
    adaptor = AdaptorPlugin(plugin, plugin_blueprint, initial, description=description, about_endpoint=about_endpoint)

    if plugin in ADAPTORS:
        raise Exception("Plug-in id already registered: %s" % plugin)

    ADAPTORS[plugin] = {
        'name': full_name,
        'adaptor': adaptor,
        'initial': initial,
        'about_endpoint': about_endpoint,
        'description': description,
    }

    return adaptor


## Tests

@adapt_blueprint.route("/more/<uuid_test>/", methods=['GET', 'POST'])
def adapt_uuid(uuid_test):
    return uuid_test


"""
@app.errorhandler(404)
def not_found(error):
    return render_template('error.html'), 404
"""
